import random
from typing import Dict, List

import numpy as np


def generate_simple_random_graph(min_node_count: int = 3,
                                 max_node_count: int = 10,
                                 node_feature_count: int = 2,
                                 additional_edge_count: int = 2,
                                 directed: bool = False) -> Dict[str, np.ndarray]:

    node_count = random.randint(min_node_count, max_node_count)
    node_attributes = np.random.uniform(0, 1, size=(node_count, node_feature_count))

    edges = []
    node_indices_inserted = [0]
    node_indices_available = list(range(1, node_count))
    random.shuffle(node_indices_available)

    # Edges between the nodes are randomly generated by always choosing one node which was
    # already inserted to the graph as an anchor point and then one which is not yet inserted
    # and connecting them through an edge
    while len(node_indices_available) != 0:
        node_index_1 = random.choice(node_indices_inserted)
        node_index_2 = node_indices_available.pop()

        if not directed:
            edges += [(node_index_1, node_index_2), (node_index_2, node_index_1)]
        else:
            edges += [(node_index_1, node_index_2)]

        node_indices_inserted.append(node_index_2)

    # After this, the generated graph is guaranteed to not contain any cycles. So now some additional
    # edges are generated to insert cross-connections between the nodes of the graph
    for i in range(additional_edge_count):
        node_index_1, node_index_2 = random.sample(node_indices_inserted, 2)

        if (node_index_1, node_index_2) not in edges and (node_index_2, node_index_1) not in edges:
            if not directed:
                edges += [(node_index_1, node_index_2), (node_index_2, node_index_1)]
            else:
                edges += [(node_index_1, node_index_2)]

    # Converting everything into numpy arrays
    edge_indices = np.array(edges, dtype=np.int32)
    edge_attributes = np.ones(shape=edge_indices.shape, dtype=np.float32)
    node_indices = np.array(list(range(node_count)), dtype=np.int32)

    # At this point the graph is represented as an array of node features and essentially a list of
    # node index tuples where each tuple represents one directed graph of the edge.
    # We want to generate an adjancency matrix here as well for completeness
    node_adjacency = np.zeros(shape=(node_count, node_count))
    for i, j in edges:
        node_adjacency[i][j] = 1

    graph = {
        'node_indices': node_indices,
        'node_attributes': node_attributes,
        'node_adjacency': node_adjacency,
        'edge_indices': edge_indices,
        'edge_attributes': edge_attributes,
    }
    return graph


def model_weights_similar(weights1: List[np.ndarray],
                          weights2: List[np.ndarray],
                          threshold: float = 1e-3) -> bool:
    similar = True
    for a1, a2 in zip(weights1, weights2):
        if not np.allclose(a1, a2):
            similar = False
            break

    return similar


def x_elem(x: List[np.array],
           index: int = 0) -> List[np.array]:
    return [e[index:index + 1] for e in x]
